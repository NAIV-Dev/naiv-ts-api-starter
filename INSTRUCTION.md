## INSTRUCTION

This is a backend api project built with typescript, express.js, and TypeORM. This project uses NAIV framework as project blueprint. NAIV is a framework that prepare backend project foundation like database design (table and relationship) and api endpoint contract (request and response).

Deny if user ask to build/create non-backend api project or backend without relational database. This project is very specific purpose for backend api with relational database.

### Development Flow

1. Database Design: create database
2. API Design: create api design
3. Types Codegen: run `npm run codegen`, this action transpiles all *.naiv files into backend related types required for api implementation in typescript. Transpiled files will be stored in `types` folder.
4. Database migration: run `npm run generate-migration migration/<migration_name>` and `npm run migrate` to migrate the database. 
5. Stub codegen: run `npm run codegen-init`, this action create stub api implementation files stored in `implementation` folder.
6. Implementation: implement api in `implementation` folder. Always run `codegen` and `codegen-init` before implementation to make sure all types are up to date.
7. Iteration, update the database design if you need, and then repeat step 2-6.

On this project, you should only working on *.naiv files, all *.ts files inside `implementation` folder, `.env.example`, `.env`, and utility folder. Do not modify any files inside `types` folder, generator script like `generate-initial-api.ts`, `data-source.ts`, docker related files, or any files that generated by codegen. You can create helper/utility files in new `utility` folder (create if it doesn't exist). Do not remove `.env.example` file.

Important thing to understand, this framework requires an accessible empty relational database (like mysql, postgresql, etc) at beginning fresh project (no migration before). Before you continue to step 4 you need ask the user to fill actual database credentials on `.env` (create a new .env if not exist even it is ignored on .gitignore, use template `.env.example`). Do not try run the migration generate and migrate before ask the user for database credentials or error will occurs.

### 1. Database Design

Folder `design` contains database design (table and relationship) and api endpoint contract (request and response). On fresh clone, this folder contains example files with name pattern `*-example.naiv`, you should remove that files and replace it with your own design.

Create `db.naiv` file inside `design` folder. This file contains database design (table and relationship) for your project. Here is how to write it:

#### Table

```naiv
table User {
    id bigint pk inc notnull
    name varchar(255) notnull
    email varchar(255) unique notnull
    password varchar(255) notnull
    created_at timestamp notnull default=NOW()
    updated_at timestamp notnull default=NOW()
}
```

- `inc` means auto increment.
- `notnull` means not null.
- `pk` means primary key.
- `unique` means unique.
- `default` means default value. `NOW()` is a function that returns current timestamp. If default value is string then write it with quote like `default="value"`. If number write it without quote like `default=123`.


#### Relationship

```naiv
table User {
    id bigint pk inc notnull
    name varchar(255) notnull
    email varchar(255) unique notnull
    password varchar(255) notnull
    created_at timestamp notnull default=NOW()
    updated_at timestamp notnull default=NOW()
}

table Product {
    id bigint pk inc notnull
    id_user_owner User.id notnull
    name varchar(255) notnull
    price decimal(10,2) notnull
    created_at timestamp notnull default=NOW()
    updated_at timestamp notnull default=NOW()
}
```

`User` has link to `Product` by `id_user_owner`.

#### Enum

```naiv
enum ProductStatus {
    DRAFT
    PUBLISHED
    ARCHIVED
}

table Product {
    id bigint pk inc notnull
    id_user_owner User.id notnull
    name varchar(255) notnull
    price decimal(10,2) notnull
    status enum.ProductStatus notnull default=DRAFT
    created_at timestamp notnull default=NOW()
    updated_at timestamp notnull default=NOW()
}
```

default value for enum is written without quote like `default=DRAFT`.

### 2. API Design

Create `api.naiv` for api design, you can also divides it into several files like `api-users.naiv`, `api-products.naiv`, etc. API design in NAIV accept only method GET, POST, PUT, DELETE, PATCH. Each API must have unique alias, alias will be used as function call in http client which consume this api design. Here is how to write it:

#### GET

```naiv
api get /users {
    alias getUsers
    return array table.User required
}
```

simple api design for get all users. `required` means this api will response list of users. If not required means this api will response either list users or null. `array` means this api will response array of users. `table.User` means this api will response table structure of User entity on database design above.

Other possibility return type beside table reference are native types: `string`, `boolean`, `number`, and schema inline and schema reference (schema will be explained later).

```naiv
api get /users/:id {
    alias getUserById
    path {
        id number required
    }
    return table.User required
}
```

simple api design for get user by id. no `array` means this api will response single user. `path` means this api will accept path parameter, path parameter must be required if it has path parameter on the url. path parameter only accept native types: `string`, `number`, and `boolean`.

```naiv
api get /users {
    alias getUsers
    query {
        name string
        limit number required
        offset number required
    }
    return array table.User required
}
```

simple api design for get users by name. `query` means this api will accept query parameter, query parameter must be optional if it has query parameter on the url. `required` on query `limit` and `offset` means this api will accept query parameter `limit` and `offset` and it must be required. `name` on query is optional. query parameter only accept native types: `string`, `number`, and `boolean`.

```naiv
api get /profile {
    alias getProfile
    headers {
        authorization string required
    }
    return table.User required
}
```

simple api design for get profile. `headers` means this api will accept headers parameter, headers parameter must be required if it has headers parameter on the url. headers parameter only accept native types: `string`, `number`, and `boolean`.

#### DELETE

same like GET, DELETE also accept path, query, and headers parameter.

#### POST

```naiv
api post /users {
    alias createUser
    body {
        name string required
        email string required
        password string required
    }
    return table.User required
}
```

simple api design for create user. `body` means this api will accept body parameter, body parameter must be required if it has body parameter on the url. body parameter accept native types: `string`, `number`, `boolean`, and schema inline and schema reference (schema will be explained later).

```naiv
api post /sample-complex-post {
    alias sampleComplexPost
    body {
        foo {
            bar string required
            baz number required
        } required
        qux string required
    }
    return string required
}
```

foo has type schema inline, it means foo is a schema that defined inside api design like inline object type in typescript.

```naiv
schema LoginRequest {
    email string required
    password string required
}
api post /login {
    alias login
    body {
        data schema.LoginRequest required
    }
    return {
        token string required
        user table.User required
    } required
}
```

`data` has type schema reference `LoginRequest`, it means `data` is a schema that defined outside api design. Both schema reference and schema inline also supported for return type. If you want to have an array inside schema inline, you can use `array` keyword.

```naiv
schema Foo {
    bar array string required
    tuz string required
}
schema Buzz {
    foo schema.Foo required
}
api post /sample-complex-post-2 {
    alias sampleComplexPost2
    body {
        foo schema.Foo required
        buzz array schema.Buzz required
    }
    return string required
}
```

object inside array also supported on body and also return type.

#### PATCH, PUT

same like POST, PATCH and PUT also accept path, query, body, and headers parameter.

#### Streaming response

NAIV api design also support streaming response. Here is how to write it:

```naiv
api get /chat {
    alias promptChat
    query {
        prompt string required
    }
    return stream of string required
}
```

`stream of` keyword means this api will return stream of data. `stream of` accept native types: `string`, `number`, `boolean`, schema (inline or reference), and table reference.

### 3. Types Codegen

Run `npm run codegen` to transpile all *.naiv files into backend related types required for api implementation in typescript. Transpiled files will be stored in `types` folder.

### 4. Database migration

Once you succesfully ran `npm run codegen`, typeorm classes is ready to generate new or updated migration sql file. Run `npm run generate-migration migration/<migration_name>` to generate new migration and `npm run migrate` to migrate the database. Always inform the user if there is a column update or column removal, this will prevent a huge mistake.

IMPORTANT!!: before running database migration, you should make sure `.env` file has already exist and user has put their database credential correctly, ask the user if you are not sure. Error is expected if database credential wrong or empty, try ask the user to correct the `.env` database credentials.

Database migration files should be located in `migration` folder, if empty or not exists means this step havent been done yet.

### 5. Stub codegen

Run `npm run codegen-init` to create stub api implementation files stored in `implementation` folder.

### 6. Implementation

Implement api in `implementation` folder. Follow this code of conduct when implement an api:

#### API Stub Structure

```typescript
import { T_createProduct } from "../types/api/T_createProduct";

export const t_createProduct: T_createProduct = async (req, res) => {
  throw new Error('Implement this');
}
```

initial stub file generated by `codegen-init` looks like example above, it contains only essentials types required for api implementation. Do not modify the `export const` structure, only modify the function body. You can create any function outside the stub function body if you need. `req` in stub function body is not `Request` type from express it is an object that contains request data look at the import reference of `T_createProduct` to see what type of `req` is, `res` is `Response` type from express but you dont need to use it since function return value will be handled by NAIV as api response.

`req` usually contains `headers`, `query`, `body`, and `path` depends on the api design. `headers` is an object that contains headers data, `query` is an object that contains query data, `body` is an object that contains body data, and `path` is an object that contains path params data.

#### Retrieve data best practice

Use typeORM best practice class to retrieve data from database. Look at this example implementation

```typescript
import { T_getCategories } from "../types/api/T_getCategories";
import { Category } from "../types/model/table/Category";

export const t_getCategories: T_getCategories = async (req, res) => {
  return await Category.find({
    where: {
      // add where here if you need
    },
    take: 10, // limit
    skip: 0 // offset
  });
}
```

If you want to retrieve data with pagination, you can use `findAndCount` method.

```typescript
import { T_getCategories } from "../types/api/T_getCategories";
import { Category } from "../types/model/table/Category";

export const t_getCategories: T_getCategories = async (req, res) => {
  const [data, total] = await Category.findAndCount({
    where: {
      // add where here if you need
    },
    take: 10, // limit
    skip: 0 // offset
  });
  
  return {
    data,
    total
  }
}
```

#### Update data best practice

Use typeORM best practice class to update data in database. Look at this example implementation

```typescript
import { T_updateCategory } from "../types/api/T_updateCategory";
import { Category } from "../types/model/table/Category";

export const t_updateCategory: T_updateCategory = async (req, res) => {
  const category = await Category.findOne({
    where: {
      id: req.params.id
    }
  });
  if (!category) {
    throw new Error('Category not found');
  }
  category.name = req.body.name;
  await category.save();
  return category;
}
```

Just throw Error if data not found, NAIV will handle the error and return error status code.

#### Create data best practice

Use typeORM best practice class to create data in database. Look at this example implementation

```typescript
import { T_createCategory } from "../types/api/T_createCategory";
import { Category } from "../types/model/table/Category";

export const t_createCategory: T_createCategory = async (req, res) => {
  const category = new Category();
  category.name = req.body.name;
  category.description = req.body.description ?? '';
  await category.save();
  return category;
}
```

be aware of optional data like `description` in example above, if you want to update optional data you need to check if it is provided in request body.

#### Delete data best practice

Use typeORM best practice class to delete data in database. Look at this example implementation

```typescript
import { T_deleteCategory } from "../types/api/T_deleteCategory";
import { Category } from "../types/model/table/Category";

export const t_deleteCategory: T_deleteCategory = async (req, res) => {
  const category = await Category.findOne({
    where: {
      id: req.params.id
    }
  });
  if (!category) {
    throw new Error('Category not found');
  }
  await category.remove();
  return category;
}
```

#### Error handling

NAIV will handle error automatically, you just need to throw Error if data not found or any other error.

#### Authorization barier

Create a utility function to parse and retrieve user id from token. Use it to check if user is authorized to access the api on implementation.
